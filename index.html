<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Harpagia Soulstone Optimizer - Legal Grimoires</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">
<style>
body{
  font-family: 'Cinzel', serif;
  background: linear-gradient(135deg, #2b0a3d, #4b1e65, #1b0f2f);
  color:#f0e6f5;
  padding:20px;
}
h1{
  font-family: 'MedievalSharp', cursive;
  font-size: 36px;
  color: #ffdb6b;
  text-shadow: 0 0 8px #ffdb6b, 0 0 12px #a64ca6;
}
select,button,input{
  padding:6px;
  font-size:15px;
  margin:4px;
  border-radius:4px;
  border: 1px solid #7c4c99;
  background:#2f1b3f;
  color:#f0e6f5;
}
button{
  padding:10px 18px;
  background:#7c4c99;
  border:none;
  color:#fff;
  cursor:pointer;
  font-weight:bold;
  text-shadow: 0 0 3px #000;
}
button:hover{
  background:#9c6fc4;
}
.build{
  background:#3b1f52;
  padding:12px;
  margin-top:15px;
  border-radius:6px;
  box-shadow: 0 0 10px rgba(255,219,107,0.3);
}
.section{
  margin-top:10px;
  font-weight:bold;
  text-shadow: 0 0 2px #000;
}
.affix{
  margin-left:12px;
}
.total{color:#7CFF9B;}
.error{color:#FF6B6B;}
.infoBox{
  background:#2a1338; 
  padding:10px; 
  border-radius:6px; 
  margin-bottom:15px;
  box-shadow: 0 0 6px rgba(255,219,107,0.2);
}
.infoBox div{
  color:#fff; 
  outline:none;
}
</style>
</head>
<body>

<h1>Harpagia Soulstone Optimizer</h1>

<div class="infoBox">
 <strong>User Instructions:</strong> If you have any issues ping <strong>ùî∏ùï•ùïùùïíùï§„ÉÉ</strong> on Discord.
  <div contenteditable="true">
 V2 supports <strong>ALL</strong> builds from 3/3/3 up to 3/3/3/3.
    <div>Select Affix's and values <strong>in order.</strong></div>
    <div>Select Affix 4 as desired overflow.</div>
    <div>Selecting "Any" for Grimoires assumes you have <strong>ALL</strong> of them.</div>
<div>IF your result seems off - switch grimoire <strong>value</strong> selections around from <strong>slot 1 to slot 2.</strong></div>
<div>When making 3/3/3+ builds Grimoire slot 1 prefers "main" affixes on the Soulstone while Grimoire slot 2 will prefer the 4th "overflow" affix.</div>   
  </div>
</div>

<div>
Select 4 Affixes (#4 is overflow):
<br>
<select id="a1"></select>
<select id="a2"></select>
<select id="a3"></select>
<select id="a4"></select>
</div>

<div style="margin-top:10px">
Soulstone Starting Values (1‚Äì10) for first three affixes:
<br>
<input id="v1" type="number" min="0" max="10" value="3">
<input id="v2" type="number" min="0" max="10" value="6">
<input id="v3" type="number" min="0" max="10" value="9">
</div>

<div class="section">
Select Grimoires (Player-Owned or ‚ÄúAny‚Äù)
<br>
<select id="g1Affix"><option value="Any">Any</option></select>
<select id="g1Value">
  <option value="3">3</option>
  <option value="6">6</option>
  <option value="9">9</option>
  <option value="12">12</option>
</select>
<select id="g2Affix"><option value="Any">Any</option></select>
<select id="g2Value">
  <option value="3">3</option>
  <option value="6">6</option>
  <option value="9">9</option>
  <option value="12">12</option>
</select>
</div>

<button onclick="run()">Optimize My Build</button>

<div id="output"></div>

<script>
const AFFIXES = [
 "Vengeance","Juggernaut","Ability Master","Hexed",
 "Adrenaline","Precision","Blunt Force","Bloodlust",
 "Preemptive Strike","Tenacity","Fortitude","Merciless",
 "Heavy Armor","Emergency Rescue","Bountiful","Haste"
];

const GLYPH_VALUE = 3;
const TARGET = 15;
const GRIMOIRE_VALUES = [3,6,9,12];

function populate(){
  [a1,a2,a3,a4,g1Affix,g2Affix].forEach(sel=>{
    AFFIXES.forEach(a=>{
      const o=document.createElement("option");
      o.value=a; o.textContent=a;
      sel.appendChild(o);
    });
  });
}
populate();

function combinations(arr,k){
  const result=[];
  function comb(temp,start){
    if(temp.length===k){
      result.push(temp.slice());
      return;
    }
    for(let i=start;i<arr.length;i++){
      temp.push(arr[i]);
      comb(temp,i+1);
      temp.pop();
    }
  }
  comb([],0);
  return result;
}

function generateGlyphSets(affixes){
  const allPairs = combinations(affixes,2);
  const sets=[];
  for(let i=0;i<allPairs.length;i++){
    for(let j=0;j<allPairs.length;j++){
      for(let k=0;k<allPairs.length;k++){
        const glyphs=[allPairs[i],allPairs[j],allPairs[k]];
        if(glyphs.some(g=>g[0]===g[1])) continue;
        sets.push(glyphs);
      }
    }
  }
  return sets;
}

function assignGrimoire(affix, nodes, totals){
  if(totals[affix]>=TARGET) return 0;
  const assign = GRIMOIRE_VALUES.filter(v=>v<=Math.min(nodes, TARGET - totals[affix])).pop() || 0;
  totals[affix] += assign;
  return assign;
}

// --------------------
// Calculate totals with redistribution to underfilled affixes
function calcTotals(soulstone,glyphs,grimoires){
  const totals={};
  soulstone.forEach(s=>totals[s.name]=(totals[s.name]||0)+s.nodes);

  glyphs.forEach(g=>{
    totals[g[0]]=(totals[g[0]]||0)+GLYPH_VALUE;
    totals[g[1]]=(totals[g[1]]||0)+GLYPH_VALUE;
  });

  // Track which affixes have already been assigned a grimoire
  const usedGrimoires = {};

  grimoires.forEach(g=>{
    if(g.affix==="Any"){
      const underfilled = Object.keys(totals).filter(a=>totals[a]<TARGET && !usedGrimoires[a]);
      if(underfilled.length>0){
        const aff = underfilled[0];
        const assign = assignGrimoire(aff, g.nodes, totals);
        if(assign > 0) usedGrimoires[aff] = true;
      }
    } else {
      if(!usedGrimoires[g.affix]){
        const assign = assignGrimoire(g.affix, g.nodes, totals);
        if(assign > 0) usedGrimoires[g.affix] = true;
      }
    }
  });

  // Redistribute excess from first 3 affixes to 4th affix
  const fourthAffix = Object.keys(totals)[3];
  let excess = 0;
  Object.keys(totals).slice(0,3).forEach(a=>{
    if(totals[a]>TARGET){
      excess += totals[a]-TARGET;
      totals[a] = TARGET;
    }
  });
  if(totals[fourthAffix]<TARGET){
    const assign = Math.min(excess, TARGET - totals[fourthAffix]);
    totals[fourthAffix] += assign;
  }

  return totals;
}

// --------------------
function solveBuilds(A,soulVals,playerGrimoires){
  const soulstone=[
    {name:A[0],nodes:soulVals[0]},
    {name:A[1],nodes:soulVals[1]},
    {name:A[2],nodes:soulVals[2]},
    {name:A[3],nodes:0}
  ];

  const glyphSets=generateGlyphSets(A);
  const builds=[];

  for(const glyphs of glyphSets){
    const totals=calcTotals(soulstone,glyphs,playerGrimoires);
    const fullT3 = Object.values(totals).every(v=>v>=TARGET);
    builds.push({soulstone,glyphs,grimoires:playerGrimoires,totals,full:fullT3});
  }

  builds.sort((a,b)=>{
    if(a.full && !b.full) return -1;
    if(!a.full && b.full) return 1;
    const aVals=[a.totals[A[0]],a.totals[A[1]],a.totals[A[2]],a.totals[A[3]]];
    const bVals=[b.totals[A[0]],b.totals[A[1]],b.totals[A[2]],b.totals[A[3]]];
    for(let i=0;i<3;i++){
      if(aVals[i]!==bVals[i]) return bVals[i]-aVals[i];
    }
    return bVals[3]-aVals[3];
  });

  return builds.slice(0,5);
}

function run(){
  const A=[a1.value,a2.value,a3.value,a4.value];
  if(new Set(A).size!==4){
    alert("Choose four different affixes.");
    return;
  }

  const vals=[Number(v1.value),Number(v2.value),Number(v3.value)];
  if(vals.some(v=>v<0||v>10)){
    alert("Soulstone values must be between 0 and 10.");
    return;
  }

  const playerGrimoires=[
    {affix:g1Affix.value,nodes:Number(g1Value.value)},
    {affix:g2Affix.value,nodes:Number(g2Value.value)}
  ];

  const builds=solveBuilds(A,vals,playerGrimoires);
  const out=document.getElementById("output");
  out.innerHTML="";

  if(builds.length===0){
    out.innerHTML="<div class='error'>No valid build or fallback found.</div>";
    return;
  }

  builds.forEach((build,index)=>{
    const div=document.createElement("div");
    div.className="build";

    const simplifiedGrimoires=[];
    const totalsWithoutGrim={};
    build.soulstone.forEach(s=>totalsWithoutGrim[s.name]=s.nodes);
    build.glyphs.forEach(g=>{
      totalsWithoutGrim[g[0]]=(totalsWithoutGrim[g[0]]||0)+GLYPH_VALUE;
      totalsWithoutGrim[g[1]]=(totalsWithoutGrim[g[1]]||0)+GLYPH_VALUE;
    });

    const usedGrimoires = {};
    for(const g of build.grimoires){
      let aff;
      if(g.affix==="Any"){
        aff = Object.keys(totalsWithoutGrim).find(a=>totalsWithoutGrim[a]<TARGET && !usedGrimoires[a]);
      } else {
        aff = g.affix;
      }
      if(aff && !usedGrimoires[aff]){
        const assign = assignGrimoire(aff, g.nodes, totalsWithoutGrim);
        if(assign>0){
          simplifiedGrimoires.push({affix:aff,nodes:assign});
          usedGrimoires[aff] = true;
        }
      }
    }

    div.innerHTML=`
      <div class="section">Build ${index+1} ${build.full?"(Full T3)":"(Fallback)"}</div>

      <div class="section">Soulstone</div>
      ${build.soulstone.map(s=>`<div class="affix">${s.name}: ${s.nodes}</div>`).join("")}

      <div class="section">Glyphs (+3 each)</div>
      ${build.glyphs.map(g=>`<div class="affix">${g[0]} (+3) + ${g[1]} (+3)</div>`).join("")}

      <div class="section">Grimoires</div>
      ${simplifiedGrimoires.map(r=>`<div class="affix">${r.affix}: ${r.nodes}</div>`).join("")}

      <div class="section">Totals</div>
      ${Object.entries(build.totals).map(([k,v])=>`<div class="affix total">${k}: ${v}</div>`).join("")}
    `;
    out.appendChild(div);
  });
}
</script>
</body>
</html>
